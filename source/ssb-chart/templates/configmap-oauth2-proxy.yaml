{{- if and (and ( or (eq (toString .Values.oauth2Proxy.enabled) "true") (eq (toString .Values.oauth2Proxy.enabled) "True")) .Values.oauth2Proxy.enabled) (eq .Values.appType "frontend") }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ template "app.name" . }}-oauth2-proxy-client-config
  labels:
{{ include "default.labels" . | indent 4 }}
data:
  oauth2-proxy-client-config.yaml: |-
    #
    # This file is managed by Ansible, manual changes will be lost
    #
    # Oauth2 proxy configuration file.
    #
    # The Oauth2 proxy uses cookies for session management.
    #
    # After the user authenticates and returns here with a code, the proxy will
    # exchange that code for an access, id and refresh token with Keycloak.
    #
    # The proxy will use the refresh token to keep the session alive. It does this
    # by refreshing all above mentioned tokens every "cookie_refresh" time or when
    # the access token has expired (5m in Keycloak) and will continue to do so for
    # max "cookie_expire" time (8h here) or until the refresh token has expired.
    #
    # The session will also expire after 30 minutes of inactivity because the
    # default refresh token expiry time in Keycloak is 30 minutes. This happens if
    # the user was inactive and the proxy has not been able to refresh the tokens
    # during that time. When the refresh token or session cookie expires the user
    # will be redirected back for authentication.
    #
    # The expiration time for the tokens themselves are controlled by the tokens
    # "exp" claim, but will be updated on every refresh. We need to make sure that
    # the proxy session timeout is longer than the refresh token expiry time to
    # avoid that the session disappears while the token is still valid.

    # The provider type.
    provider = "oidc"

    # Skip local "sign-in-page" and start Oauth flow directly.
    skip_provider_button = true

    skip_oidc_discovery = true
    # OpenID Connect issuer URL.
    redeem_url = "http://keycloak.sso.svc.cluster.local/realms/ssb/protocol/openid-connect/token"
    oidc_issuer_url = "https://sso.dev-bip-app.ssb.no/realms/ssb"
    login_url = "https://sso.dev-bip-app.ssb.no/realms/ssb/protocol/openid-connect/auth"
    oidc_jwks_url = "http://keycloak.sso.svc.cluster.local/realms/ssb/protocol/openid-connect/certs"

    # Tenant ID for Microsoft IdP (Azure AD)

    # The <addr>:<port> to listen on for HTTP/HTTPS clients.
    http_address = "0.0.0.0:4180"

    # The Oauth Redirect URL. Defaults to "https://<HOST>/oauth2/callback".
    # Example:
    # redirect_url = "https://<hostname>/oauth2/callback"


    # This will restrict login to accounts with email address in the
    # configured domain.
    email_domains = [
      "ssb.no"
    ]

    # Request "standard" scopes from Keycloak.
    scope = "openid email profile"


    # Skip authentication for OPTIONS requests by default. This is needed to allow
    # CORS request that comes before the actual HTTP GET/POST requests.
    skip_auth_preflight = true

    ## Headers

    # Passing of OIDC ID-Token to upstream in a Authorization Bearer header.
    pass_authorization_header = true

    # Passing the request Host Header to upstream. If set to "false" the
    # host of the upstream will be used.
    pass_host_header = true

    # Passing HTTP Basic Auth, X-Forwarded-User and X-Forwarded-Email
    # information to upstream.
    pass_basic_auth = false

    # Passing Oauth access_token to upstream via X-Forwarded-Access-Token
    # header.
    pass_access_token = false

    # Passing X-Forwarded-User and X-Forwarded-Email to upstream.
    pass_user_headers = false

    # Setting Authorization Bearer header for Nginx auth_request mode.
    set_authorization_header = false

    # Set X-Auth-Request-User and X-Auth-Request-Email response headers
    # for Nginx auth_request mode.
    set_xauthrequest = false

    ## Cookie settings

    # Base name of cookies to store tokens.
    cookie_name = "oauth2_proxy"

    # An active session can be max 8 hours long.
    cookie_expire = "8h"

    # Refresh cookies and tokens after max 10 minutes. This value should be larger
    # than the expiry of the access token and probably less than "cookie_expire".
    cookie_refresh = "10m"

    # HTTPS only cookies.
    cookie_secure = true

    # Not available to Javascript.
    cookie_httponly = true

    # Use redis storage for session store instead of cookies. Depends on redis being
    # setup as a sidecar on specified port. Platform-dev example:
    #    sidecars:
    #    - name: redis
    #      image: docker.io/library/redis:alpine3.12
    #      imagePullPolicy: Always

    ## skip SSL checking for HTTPS requests
    ssl_insecure_skip_verify = true

    code_challenge_method = "S256"
{{- end }}

